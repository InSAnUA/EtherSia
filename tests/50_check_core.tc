#include "EtherSia.h"
#include "util.h"
#suite Core

const char local_mac[] = "ca:2f:6d:70:f9:5f";
IPv6Address ourLinkLocal("fe80::c82f:6dff:fe70:f95f");
IPv6Address googleDns("2001:4860:4860::8888");


#test default_dns_server
EtherSia_Dummy ether;
ether.setGlobalAddress("2001::1");
ether.begin(local_mac);
ck_assert(ether.dnsServerAddress() == googleDns);


#test sets_linklocal_address
EtherSia_Dummy ether;
ether.setGlobalAddress("2001::1");
ether.begin(local_mac);
IPv6Address addr("fe80:0000:0000:0000:c82f:6dff:fe70:f95f");
ck_assert(ether.linkLocalAddress() == addr);


#test isOurAddress
EtherSia_Dummy ether;
ether.setGlobalAddress("2001:1234::c82f:6dff:fe70:f95f");
ether.begin(local_mac);

ck_assert_int_eq(ether.isOurAddress(ourLinkLocal), ADDRESS_TYPE_LINK_LOCAL);

IPv6Address expect_global("2001:1234::c82f:6dff:fe70:f95f");
ck_assert_int_eq(ether.isOurAddress(expect_global), ADDRESS_TYPE_GLOBAL);

IPv6Address expect_allnodes("ff02::1");
ck_assert_int_eq(ether.isOurAddress(expect_allnodes), ADDRESS_TYPE_MULTICAST);

IPv6Address expect_nodemulticast("ff02::1:ff70:f95f");
ck_assert_int_eq(ether.isOurAddress(expect_nodemulticast), ADDRESS_TYPE_MULTICAST);

ck_assert_int_eq(ether.isOurAddress(googleDns), 0);

IPv6Address other_global("2a02:26f0::c82f:6dff:fe70:f95f");
ck_assert_int_eq(ether.isOurAddress(other_global), 0);


#test inOurSubnet
EtherSia_Dummy ether;
ether.setGlobalAddress("2001:1234::c82f:6dff:fe70:f95f");
ether.begin(local_mac);

IPv6Address expect_linklocal("fe80::d1c5:a0a3:746b:5f9a");
ck_assert_int_eq(ether.inOurSubnet(expect_linklocal), ADDRESS_TYPE_LINK_LOCAL);

IPv6Address expect_global("2001:1234::1");
ck_assert_int_eq(ether.inOurSubnet(expect_global), ADDRESS_TYPE_GLOBAL);

ck_assert_int_eq(ether.inOurSubnet(googleDns), 0);


#test no_packets_available
EtherSia_Dummy ether;
ether.setGlobalAddress("2001::1");
ether.begin(local_mac);

ether.clearRecieved();
ck_assert(ether.receivePacket() == 0);


#test recieve_ipv6_packet
EtherSia_Dummy ether;
ether.setGlobalAddress("2001::1");
ether.begin(local_mac);

const uint8_t valid_ipv6packet[] = {
    0xca, 0x2f, 0x6d, 0x70, 0xf9, 0x5f,  // Ethernet Destination
    0xa4, 0x5e, 0x60, 0xda, 0x58, 0x9d,  // Ethernet Source
    0x86, 0xdd,                          // EtherType
    0x60, 0x05, 0x37, 0xcf,              // IPv6 header
    0x00, 0x10,                          // Length (16 bytes)
    0x3a,                                // Protocol
    0x40,                                // Hop Limit
    0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa6, 0x5e, 0x60, 0xff, 0xfe, 0xda, 0x58, 0x9d,
    0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x2f, 0x6d, 0xff, 0xfe, 0x70, 0xf9, 0x5f,
    0x80, 0x00, 0x0b, 0x50, 0x23, 0x1b, 0x00, 0x07,   // ICMPv6 header
    0x58, 0x07, 0xf2, 0x7d, 0x00, 0x0d, 0x7c, 0xd8    // Data
};
ether.injectRecievedPacket((void*)valid_ipv6packet, sizeof(valid_ipv6packet));
ck_assert_int_eq(ether.receivePacket(), 70);
ck_assert_int_eq(ether.packet().length(), 70);
ck_assert_int_eq(ether.packet().payloadLength(), 16);
ck_assert_int_eq(ether.packet().protocol(), IP6_PROTO_ICMP6);


#test ignores_ipv4_packet
EtherSia_Dummy ether;
ether.setGlobalAddress("2001::1");
ether.begin(local_mac);

const uint8_t ipv4packet[] = {
    0xca, 0x2f, 0x6d, 0x70, 0xf9, 0x5f,     // Ethernet Destination
    0x02, 0xc0, 0xde, 0x02, 0x02, 0x02,     // Ethernet Source
    0x08, 0x00,                             // EtherType (IPv4)
    0x45, 0x00,
    0x00, 0x32, 0x56, 0x66, 0x00, 0x00, 0x40, 0x11, 0xa2, 0xe4, 0xc0, 0xa8, 0x00, 0x1f, 0xc0, 0xa8,
    0x00, 0x01, 0xcf, 0x89, 0x00, 0x35, 0x00, 0x1e, 0x71, 0x70, 0xc9, 0x37, 0x01, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x74, 0x02, 0x63, 0x6f, 0x00, 0x00, 0x01, 0x00, 0x01
};
ether.injectRecievedPacket((void*)ipv4packet, sizeof(ipv4packet));
ck_assert(ether.receivePacket() == 0);
ck_assert(ether.bufferContainsReceived() == false);

